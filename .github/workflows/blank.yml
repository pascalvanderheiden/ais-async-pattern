# This is a basic workflow to help you get started with Actions

name: CI

env:
  COSMOSCON: 'customer-con'
  SERVICEBUSQUEUE: 'customer-queue'
  COSMOSCONPARTKEY: '/message/lastName'
  RESOURCEGROUP: 'mcmaisd-rg'
  LOCATION: 'westeurope'
  COSMOSACC: 'mcmaisd-acc'
  COSMOSDB: 'mcmaisd-db'
  APIM: 'mcmaisd'
  SERVICEBUSNS: 'mcmaisd-ns'
  LOGANALYTICS: 'mcmaisd-ws'
  KV: 'mcmaisd-kv'
  KVSERVICEBUSLABEL: 'mcmaisdcosmosdb'
  KVCOSMOSDBLABEL: 'mcmaisdservicebus'
  APPINSIGHTS: 'mcmaisd-ai'

# Controls when the action will run. 
on:
  # Triggers the workflow on push or pull request events but only for the master branch
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

  # Allows you to run this workflow manually from the Actions tab
  workflow_dispatch:

# A workflow run is made up of one or more jobs that can run sequentially or in parallel
jobs:
  # This workflow contains a single job called "build"
  deploy_cosmos_db:
    # The type of runner that the job will run on
    runs-on: ubuntu-latest

    outputs:
      COSMOSDBKEY: ${{ env.COSMOSDBKEY }}

    # Steps represent a sequence of tasks that will be executed as part of the job
    steps:
      # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it
      - uses: actions/checkout@v2
      
      - uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: 'Creating Cosmos DB Account ${{ env.COSMOSACC }}'
        uses: azure/CLI@v1
        with:
          inlineScript: |
            RESULT=$(az cosmosdb check-name-exists -n ${{ env.COSMOSACC }})
            if [ "$RESULT" != "true" ]
            then
              az cosmosdb create -n ${{ env.COSMOSACC }} -g ${{ env.RESOURCEGROUP }}
              # Get Secure Connection String
              COSMOSDBKEY=$(az cosmosdb keys list -n ${{ env.COSMOSACC }} -g ${{ env.RESOURCEGROUP }} --type keys --query primaryMasterKey -o tsv)
            else
              echo "   Cosmos DB Account ${{ env.COSMOSACC }} already exists, retrieve key"
              COSMOSDBKEY=$(az cosmosdb keys list -n ${{ env.COSMOSACC }} -g ${{ env.RESOURCEGROUP }} --type keys --query primaryMasterKey -o tsv)
            fi
             echo COSMOSDBKEY=$COSMOSDBKEY >> $GITHUB_ENV

      - name: "Creating Cosmos DB Account ${{ env.COSMOSDB }}"
        uses: azure/CLI@v1
        with:
          inlineScript: |
            RESULT=$(az cosmosdb sql database show -n ${{ env.COSMOSDB }} -a ${{ env.COSMOSACC }} -g ${{ env.RESOURCEGROUP }})
            if [ "$RESULT" = "" ]
            then
              az cosmosdb sql database create -a ${{ env.COSMOSACC }} -g ${{ env.RESOURCEGROUP }} -n ${{ env.COSMOSDB }} --throughput 400
            else
              echo "   Cosmos DB Database ${{ env.COSMOSDB }} already exists"
            fi          

      - name: "Creating Cosmos DB Container ${{ env.COSMOSCON }}"
        uses: azure/CLI@v1
        with:
          inlineScript: |
            RESULT=$(az cosmosdb sql container show -a ${{ env.COSMOSACC }} -g ${{ env.RESOURCEGROUP }} -n ${{ env.COSMOSCON }} -d ${{ env.COSMOSDB }})
            if [ "$RESULT" = "" ]
            then
              az cosmosdb sql container create -a ${{ env.COSMOSACC }} -g ${{ env.RESOURCEGROUP }} -n ${{ env.COSMOSCON }} -d ${{ env.COSMOSDB }} -p "${{ env.COSMOSCONPARTKEY }}"
            else
              echo "   Cosmos DB Container ${{ env.COSMOSCON }} already exists"
            fi

      - name: logout
        run: |
          az logout

  deploy_loganalytics:
    # The type of runner that the job will run on
    runs-on: ubuntu-latest

    # Steps represent a sequence of tasks that will be executed as part of the job
    steps:
      # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it
      - uses: actions/checkout@v2
      
      - uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: "Creating Log Analytics Workspace ${{ env.LOGANALYTICS }}"
        uses: azure/CLI@v1
        with:
          inlineScript: |
            echo "Creating Log Analytics Workspace ${{ env.LOGANALYTICS }}"
            RESULT=$(az monitor log-analytics workspace show -g ${{ env.RESOURCEGROUP }} -n ${{ env.LOGANALYTICS }})
            if [ "$RESULT" = "" ]
            then
              az monitor log-analytics workspace create -g ${{ env.RESOURCEGROUP }} -n ${{ env.LOGANALYTICS }}
            else
              echo "   Log Analytics Workspace ${{ env.LOGANALYTICS }} already exists"
            fi

      - name: logout
        run: |
          az logout

  deploy_APIM:
    # The type of runner that the job will run on
    runs-on: ubuntu-latest

    # Steps represent a sequence of tasks that will be executed as part of the job
    steps:
      # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it
      - uses: actions/checkout@v2
      
      - uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: "Creating API Management Instance ${{ env.APIM }}"
        uses: azure/CLI@v1
        with:
          inlineScript: |
            echo "Creating API Management Instance ${{ env.APIM }}"
            RESULT=$(az apim check-name -n ${{ env.APIM }})
            if [ "$RESULT" != "true" ]
            then
              az apim create -n ${{ env.APIM }} -g ${{ env.RESOURCEGROUP }} -l ${{ env.LOCATION }} --publisher-email email@mydomain.com --publisher-name Microsoft
            else
              echo "   API Management Instance ${{ env.APIM }} already exists"
            fi

      - name: logout
        run: |
          az logout

  deploy_sb:
    # The type of runner that the job will run on
    runs-on: ubuntu-latest

    outputs:
      SBCONNECTIONSTRING: ${{ env.SBCONNECTIONSTRING }}
    # Steps represent a sequence of tasks that will be executed as part of the job
    steps:
      # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it
      - uses: actions/checkout@v2
      
      - uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: "Creating Service Bus Queue ${{ env.SERVICEBUSQUEUE }}"
        uses: azure/CLI@v1
        with:
          inlineScript: |
            echo "Creating Service Bus Namespace ${SERVICEBUSNS}"
            RESULT=$(az servicebus namespace exists -n $SERVICEBUSNS)
            if [ "$RESULT" != "true" ]
            then
              az servicebus namespace create -g $RESOURCEGROUP -n $SERVICEBUSNS -l $LOCATION --sku Premium
              # Create a authorization rule for the Logic App (for the name of the rule I'm using the same label as that of the Key Vault entry)
              az servicebus namespace authorization-rule create -g $RESOURCEGROUP --namespace-name $SERVICEBUSNS -n $KVSERVICEBUSLABEL --rights Listen Send
              # Get Secure Connection String
              SBCONNECTIONSTRING=$(az servicebus namespace authorization-rule keys list -g $RESOURCEGROUP --namespace-name $SERVICEBUSNS -n $KVSERVICEBUSLABEL --query primaryConnectionString -o tsv)
            else
              echo "   Service Bus Namespace ${SERVICEBUSNS} already exists, retrieve connection string"
              SBCONNECTIONSTRING=$(az servicebus namespace authorization-rule keys list -g $RESOURCEGROUP --namespace-name $SERVICEBUSNS -n $KVSERVICEBUSLABEL --query primaryConnectionString -o tsv)
            fi
            echo SBCONNECTIONSTRING=$SBCONNECTIONSTRING >> $GITHUB_ENV

      - name: "Creating Service Bus Queue ${{ env.SERVICEBUSQUEUE }}"
        uses: azure/CLI@v1
        with:
          inlineScript: |
            echo "Creating Service Bus Queue ${{ env.SERVICEBUSQUEUE }}"
            RESULT=$(az servicebus queue show -g ${{ env.RESOURCEGROUP }} --namespace-name ${{ env.SERVICEBUSNS }} -n ${{ env.SERVICEBUSQUEUE }})
            if [ "$RESULT" = "" ]
            then
              az servicebus queue create -g ${{ env.RESOURCEGROUP }} --namespace-name ${{ env.SERVICEBUSNS }} -n ${{ env.SERVICEBUSQUEUE }} --max-size 1024
            else
              echo "   Service Bus Queue ${{ env.SERVICEBUSQUEUE }} already exists"
            fi

      - name: logout
        run: |
          az logout

  deploy_kv:
    # The type of runner that the job will run on

    needs: [deploy_cosmos_db, deploy_sb]
    runs-on: ubuntu-latest

    # Steps represent a sequence of tasks that will be executed as part of the job
    steps:
      # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it
      - uses: actions/checkout@v2
      
      - uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: "Creating Key Vault ${{ env.KV }}"
        uses: azure/CLI@v1
        with:
          inlineScript: |
            echo "Creating Key Vault ${{ env.KV }}"
            RESULT=$(az keyvault show -n ${{ env.KV }})
            if [ "$RESULT" = "" ]
            then
              az keyvault create -l ${{ env.LOCATION }} -n $KV -g ${{ env.RESOURCEGROUP }}
              az keyvault secret set --vault-name "${{ env.KV }}" --name "${{ env.KVSERVICEBUSLABEL }}" --value "${{ needs.deploy_sb.outputs.SBCONNECTIONSTRING }}"
              az keyvault secret set --vault-name "${{ env.KV }}" --name "${{ env.KVCOSMOSDBLABEL }}" --value "${{ needs.deploy_cosmos_db.outputs.COSMOSDBKEY }}"
            else
              echo "   Key Vault ${{ env.KV }} already exists"
            fi

      - name: logout
        run: |
          az logout

  deploy_appinsights:    # The type of runner that the job will run on
    runs-on: ubuntu-latest

    # Steps represent a sequence of tasks that will be executed as part of the job
    steps:
      # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it
      - uses: actions/checkout@v2
      
      - uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: 'Deploy Appinsights ${{ env.APPINSIGHTS }}'
        uses: azure/CLI@v1
        with:
          inlineScript: |
            az deployment group create -g '${{env.RESOURCEGROUP}}' --template-file ./deploy/azuredeploy_appinsights.json --parameters "./deploy/azuredeploy_appinsights.parameters.json" --parameters ApplicationInsightsLocation='${{ env.LOCATION }}' ApplicationInsightsInstanceName='${{ env.APPINSIGHTS }}' ApimServiceName='${{ env.APIM }}'

      - name: logout
        run: |
          az logout
